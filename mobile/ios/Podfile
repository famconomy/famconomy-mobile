# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip

require 'pathname'
require 'fileutils'

platform :ios, min_ios_version_supported
prepare_react_native_project!

linkage = ENV['USE_FRAMEWORKS']
if linkage != nil
  Pod::UI.puts "Configuring Pod with #{linkage}ally linked Frameworks".green
  use_frameworks! :linkage => linkage.to_sym
end

target 'Mobile' do
  config = use_native_modules!

  pod 'GoogleUtilities', :modular_headers => true
  pod 'FirebaseCore', :modular_headers => true
  pod 'FirebaseAuth', :modular_headers => true
  pod 'FirebaseCoreInternal', :modular_headers => true
  pod 'FirebaseAppCheckInterop', :modular_headers => true
  pod 'GTMAppAuth', :modular_headers => true
  pod 'GTMSessionFetcher/Core', :modular_headers => true
  pod 'GoogleSignIn', :modular_headers => true
  pod 'PromisesObjC', :modular_headers => true

  use_react_native!(
    :path => config[:reactNativePath],
    # An absolute path to your application root.
  :app_path => "#{Pod::Config.instance.installation_root}/..",
  # Temporary: disable New Architecture (Fabric) to avoid unsupported event errors from third-party libs
  :new_arch_enabled => false
  )

  post_install do |installer|
    # https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L197-L202
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      # :ccache_enabled => true
    )

    prefix_header_fs_path = File.join(__dir__, 'RNCharTraitsFix.pch')
    unless File.exist?(prefix_header_fs_path)
      Pod::UI.warn("Missing prefix header at #{prefix_header_fs_path}")
    end
    prefix_header_build_setting = '$(PODS_ROOT)/../RNCharTraitsFix.pch'

    installer.pods_project.targets.each do |target|
      target.build_configurations.each do |configuration|
        configuration.build_settings['GCC_PREFIX_HEADER'] = prefix_header_build_setting
        configuration.build_settings['GCC_PRECOMPILE_PREFIX_HEADER'] = 'NO'

        definitions = configuration.build_settings['GCC_PREPROCESSOR_DEFINITIONS']
        definitions =
          case definitions
          when Array
            definitions.dup
          when String
            definitions.split(/\s+/)
          when NilClass
            ['$(inherited)']
          else
            Array(definitions)
          end

        definitions.delete_if { |value| value.to_s.start_with?('FMT_USE_CHAR8_T=') }
        definitions << 'FMT_USE_CHAR8_T=0'
        configuration.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] = definitions

        other_cxx_flags = configuration.build_settings['OTHER_CPLUSPLUSFLAGS']
        other_cxx_flags =
          case other_cxx_flags
          when Array
            other_cxx_flags.dup
          when String
            other_cxx_flags.split(/\s+/)
          when NilClass
            ['$(inherited)']
          else
            Array(other_cxx_flags)
          end

        other_cxx_flags.delete('-DFMT_USE_CHAR8_T=0')
        other_cxx_flags << '-DFMT_USE_CHAR8_T=0'
        other_cxx_flags.delete('-U__cpp_char8_t')
        other_cxx_flags << '-U__cpp_char8_t'
        include_path_token = '"$(PODS_ROOT)/../RNCharTraitsFix.pch"'
        other_cxx_flags.delete('-include')
        other_cxx_flags.delete_if { |value| value.include?('RNCharTraitsFix.pch') }
        other_cxx_flags += ['-include', include_path_token]
        configuration.build_settings['OTHER_CPLUSPLUSFLAGS'] = other_cxx_flags

        other_c_flags = configuration.build_settings['OTHER_CFLAGS']
        other_c_flags =
          case other_c_flags
          when Array
            other_c_flags.dup
          when String
            other_c_flags.split(/\s+/)
          when NilClass
            ['$(inherited)']
          else
            Array(other_c_flags)
          end

        other_c_flags.delete('-DFMT_USE_CHAR8_T=0')
        other_c_flags << '-DFMT_USE_CHAR8_T=0'
        other_c_flags.delete('-U__cpp_char8_t')
        other_c_flags << '-U__cpp_char8_t'
        other_c_flags.delete('-include')
        other_c_flags.delete_if { |value| value.include?('RNCharTraitsFix.pch') }
        other_c_flags += ['-include', include_path_token]
        configuration.build_settings['OTHER_CFLAGS'] = other_c_flags

        if target.name == 'hermes-engine' || target.name.start_with?('hermes-engine-')
          configuration.build_settings['ENABLE_USER_SCRIPT_SANDBOXING'] = 'NO'
        end
      end
    end


    pods_root = File.join(Pod::Config.instance.installation_root, 'Pods')


    fmt_core_header = File.join(pods_root, 'fmt', 'include', 'fmt', 'core.h')
    if File.exist?(fmt_core_header)
      contents = File.read(fmt_core_header)
      updated = false

      replacement_alias = <<~'REPLACEMENT'
#if FMT_USE_CHAR8_T && defined(__cpp_char8_t)
using char8_type = char8_t;
#else
using char8_type = char;
#endif
REPLACEMENT

      alias_regex = /#ifdef __cpp_char8_t\nusing char8_type = char8_t;\n#else\n.*?\n#endif/m
      if !contents.include?(replacement_alias.strip) && contents.match?(alias_regex)
        Pod::UI.warn 'Patching fmt char8_type alias for Xcode 16 compatibility'
        FileUtils.chmod('u+w', fmt_core_header)
        contents = contents.sub(alias_regex, replacement_alias)
        updated = true
      end

      original_is_char_block = <<~'ORIGINAL'
#if FMT_USE_CHAR8_T
template <> struct is_char<internal::char8_type> : std::true_type {};
#endif
ORIGINAL
      replacement_is_char_block = <<~'REPLACEMENT'
#if FMT_USE_CHAR8_T && defined(__cpp_char8_t)
template <> struct is_char<internal::char8_type> : std::true_type {};
#endif
REPLACEMENT
      duplicate_is_char_block = <<~'DUPLICATE'
#if FMT_USE_CHAR8_T
#if FMT_USE_CHAR8_T
template <> struct is_char<internal::char8_type> : std::true_type {};
#endif
#endif
DUPLICATE

      if contents.include?(duplicate_is_char_block)
        Pod::UI.warn 'Guarding fmt is_char specialization for char8_type'
        FileUtils.chmod('u+w', fmt_core_header)
        contents = contents.sub(duplicate_is_char_block, replacement_is_char_block)
        updated = true
      elsif contents.include?(original_is_char_block) && !contents.include?(replacement_is_char_block.strip)
        Pod::UI.warn 'Guarding fmt is_char specialization for char8_type'
        FileUtils.chmod('u+w', fmt_core_header)
        contents = contents.sub(original_is_char_block, replacement_is_char_block)
        updated = true
      end

      File.write(fmt_core_header, contents) if updated
    end

    fmt_format_header = File.join(pods_root, 'fmt', 'include', 'fmt', 'format.h')
    if File.exist?(fmt_format_header)
      contents = File.read(fmt_format_header)
      updated = false

      count_code_points_body = <<~'BODY'
inline size_t count_code_points(basic_string_view<char8_type> s) {
  return count_code_points(basic_string_view<char>(
      reinterpret_cast<const char*>(s.data()), s.size()));
}
BODY

      unguarded_char8_func = count_code_points_body
      guarded_char8_func = <<~'REPLACEMENT'
#if FMT_USE_CHAR8_T && defined(__cpp_char8_t)
inline size_t count_code_points(basic_string_view<char8_type> s) {
  return count_code_points(basic_string_view<char>(
      reinterpret_cast<const char*>(s.data()), s.size()));
}
#endif
REPLACEMENT

      if contents.include?(unguarded_char8_func)
        Pod::UI.warn 'Guarding fmt count_code_points overload for char8_type'
        FileUtils.chmod('u+w', fmt_format_header)
        contents = contents.sub(unguarded_char8_func, guarded_char8_func)
        updated = true
      end

      duplicate_pattern = /
        \#if\ FMT_USE_CHAR8_T\s*
        \#if\ FMT_USE_CHAR8_T\s*
        #{Regexp.escape(guarded_char8_func).gsub("\n", "\n\s*")}
        \s*\#endif\s*
        \#endif
      /x

      if contents.match?(duplicate_pattern)
        Pod::UI.warn 'Removing duplicate fmt count_code_points guards for char8_type'
        FileUtils.chmod('u+w', fmt_format_header)
        contents = contents.gsub(duplicate_pattern, guarded_char8_func)
        updated = true
      end

      double_guard_literal = "#if FMT_USE_CHAR8_T && defined(__cpp_char8_t)\n#if FMT_USE_CHAR8_T && defined(__cpp_char8_t)\n"
      if contents.include?(double_guard_literal)
        Pod::UI.warn 'Collapsing nested fmt count_code_points guards for char8_type'
        FileUtils.chmod('u+w', fmt_format_header)
        contents = contents.gsub(double_guard_literal, "#if FMT_USE_CHAR8_T && defined(__cpp_char8_t)\n")
        contents = contents.gsub("\n#endif\n#endif\n", "\n#endif\n")
        updated = true
      end

      File.write(fmt_format_header, contents) if updated
    end

  end
end
